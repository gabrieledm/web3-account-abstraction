# AccountAbstraction (EIP-4337)

[ERC-4337: Account Abstraction Using Alt Mempool](https://eips.ethereum.org/EIPS/eip-4337)

## Understanding Account Abstraction: Revolutionizing Blockchain User Experience

**Account Abstraction (AA)** is a pivotal development in the blockchain space, particularly within the Ethereum ecosystem through `EIP-4337`. 

## The Bottleneck: Why Traditional Crypto Wallets Hinder Adoption

The traditional approach to managing crypto assets has long been a significant barrier to widespread adoption. 

Consider the typical user journey:
1. A user receives a 12-word seed phrase.
2. This seed phrase generates a private key.
3. This private key is the sole authenticator for signing *all* transactions.

This model, while secure in theory, presents several critical pain points for the average user:
- **Complexity:** Managing seed phrases and private keys is a daunting task. Users are expected to become security experts overnight, safeguarding these cryptic strings of characters.
- **High Stakes:** The loss of a seed phrase or private key typically means irreversible loss of access to all associated funds. There are no "forgot password" options.
- **Security Risks:** If a private key or seed phrase is accidentally leaked or compromised, malicious actors can gain unfettered access to and drain the user's wallet.
- **Gas Fee Friction:** Every on-chain action, no matter how small, requires the user to hold and spend the blockchain's native token (e.g., ETH on Ethereum) for gas fees. This "gas problem" is a constant hurdle, especially for new users who might not have any native tokens to begin with.
- **Limited Wallet Privacy:** All transactions originating from a single private key are linked, potentially revealing a user's activity patterns.
- **Batching Inefficiencies:** Performing multiple operations often requires deploying an intermediary smart contract, adding complexity and cost.

These issues collectively create a poor user experience, making it difficult to onboard new users to the world of decentralized finance and Web3.

## What is Account Abstraction? The Core Shift in Transaction Validation

**Account Abstraction** fundamentally redefines how transactions are authorized and validated on a blockchain. 

The core idea is to move away from a rigid system where transaction validity is solely tied to an `Elliptic Curve Digital Signature Algorithm (ECDSA)` signature generated by a private key. 

Instead, **Account Abstraction** allows for **arbitrary validation logic** defined within a smart contract.

To put it simply:
- **Traditional Model:** Private Key = Wallet. The private key *is* the ultimate authority.
- **Account Abstraction Model:** Programmable Logic = Wallet. The authority and validation rules are defined by the code within a smart contract account.

This shift means that instead of the blockchain protocol itself dictating that only a private key signature can authorize a transaction from an `Externally Owned Account (EOA)`, the account *itself* (now a smart contract) dictates the conditions under which a transaction is considered valid.

This programmable validity opens up a wealth of possibilities:
- **Social Login/Recovery:** Users could authorize transactions using familiar credentials like a Google account, GitHub, or even biometrics, abstracting away the need to directly manage private keys.
- **Multi-signature (Multi-sig) Wallets:** Require approvals from multiple parties (e.g., three out of five authorized signers) before a transaction is executed.
- **Spending Limits:** Enforce daily, weekly, or per-transaction spending caps directly at the account level.
- **Time Locks:** Permit transactions only during specific windows (e.g., business hours) or after a certain delay.
- **Parental Controls:** A wallet for a minor could be configured such that transactions initiated by the child require approval from a parent's account before execution.

## Gas Abstraction: Solving the "Need Gas" Problem with Paymasters

A significant corollary of programmable validation is **gas abstraction**. 

Because the account's validation logic is flexible, **Account Abstraction** enables mechanisms where someone *other* than the user can pay for their transaction gas fees.

This directly addresses the friction point where users need native tokens for every interaction. 

With **Account Abstraction**, a dApp developer, a project, or a dedicated third-party service (known as a `Paymaster`) can sponsor transactions. 

The user can interact with a dApp without needing to first acquire and hold ETH (or the L2's native token) specifically for gas.

## How Account Abstraction Works: EIP-4337 vs. Native Implementations

The implementation of Account Abstraction varies, leading to different levels of complexity. 

There are two primary approaches:

1. **Ethereum (EIP-4337):** This standard implements **Account Abstraction** *on top* of the existing Ethereum protocol without requiring core consensus changes. It relies on a higher-level infrastructure, including a special smart contract (`EntryPoint.sol`) and an alternative mempool for user operations. `EIP-4337` went live on Ethereum mainnet on `March 1st, 2023`.
2. **Native Account Abstraction (e.g., zkSync):** Some Layer 2 solutions and newer blockchains build **Account Abstraction** directly *into* their core protocol. This often leads to a more streamlined and integrated experience.

### Traditional Ethereum Transaction Flow (Recap)

Before diving into `EIP-4337`, let's quickly recap the traditional Ethereum transaction flow:

1. **Off-Chain:** A user, using a wallet like MetaMask, signs transaction data with their private key. This signature, along with the transaction details and gas payment, is prepared.
2. **On-Chain:** The signed transaction is broadcast to an Ethereum node.
3. The node validates the transaction (including the signature and sufficient gas) and, if valid, adds it to its local mempool.
4. Miners/validators pick transactions from the mempool to include in a new block, which is then added to the blockchain.

### Account Abstraction on Ethereum via EIP-4337: A Detailed Look

EIP-4337 introduces a new, parallel system for transaction processing that leverages smart contracts to achieve account abstraction. 

The flow involves several key components:

1. **Deploy a Smart Contract Wallet (SCW):**
   Instead of relying solely on an EOA, the user interacts through a **Smart Contract Wallet (SCW)**. This SCW is a smart contract deployed on the blockchain (e.g., `MyNewAccount.sol`) that contains the custom validation logic. This logic dictates what constitutes a valid authorization for that specific account â€“ it could be a signature from a specific key (mimicking an EOA), a multi-sig condition, or a check against an off-chain authentication service.
2. **Construct and Send a `UserOperation (UserOp)` to the `Alt Mempool`:**
   When a user wants to perform an action (e.g., send tokens, interact with a DeFi protocol), their wallet interface (now AccountAbstraction-aware) constructs a **UserOperation (`UserOp`)** object. This is not a standard Ethereum transaction. The `UserOp` struct, defined in the `EIP-4337` specification, includes fields such as:
   - `sender`: The address of the user's SCW.
   - `nonce`: A sequence number to prevent replay attacks.
   - `callData`: The actual operation to be executed by the SCW (e.g., the function call and parameters for an ERC20 transfer).
   - Gas-related fields (`callGasLimit`, `verificationGasLimit`, `preVerificationGas`, `maxFeePerGas`, `maxPriorityFeePerGas`).
   - `paymasterAndData`: Optional data for specifying a Paymaster to sponsor gas fees.
   - `signature`: The signature that satisfies the SCW's custom validation logic.
   
   This `UserOp`, signed according to the SCW's rules, is then sent to a separate, off-chain peer-to-peer network known as the **Alternative Mempool (`Alt Mempool`)**. This mempool is specifically for `UserOps` and operates independently of Ethereum's main transaction mempool.

3. **Bundlers Process UserOps:**
   Specialized nodes participating in the `Alt Mempool` network are called **Bundlers**. Their role is to:
   - Listen for `UserOps` in the `Alt Mempool`.
   - Validate each `UserOp` by simulating its validation logic against the target SCW.
   - Bundle multiple valid `UserOps` together into a single, standard Ethereum transaction.
   - Crucially, the **Bundler pays the gas fee** for this bundled Ethereum transaction sent to the main Ethereum network. They are later compensated either by the SCWs themselves or by Paymasters.

4. **Bundler Calls the** **`EntryPoint.sol`** **Contract:**
   The Bundler submits this bundled transaction by calling a specific function (typically `handleOps`) on a single, globally deployed smart contract called **`EntryPoint.sol`**. This contract (developed and maintained by the `eth-infinitism` group, with support from the Ethereum Foundation) acts as the central orchestrator for `EIP-4337`. Its canonical address (e.g., `0x5FF137D4b0FDCD49DcA30c7CF57E578a026d2789` for v0.6/v0.7) is known and trusted.

   The `EntryPoint.sol` contract then performs its own set of critical operations:
   - It iterates through each `UserOp` in the bundle.
   - For each `UserOp`, it first verifies the `UserOp`'s signature and other parameters by calling a validation function on the user's SCW (e.g., `validateUserOp`). 
   - It checks if the SCW has enough funds to pay the Bundler for gas, or if a specified Paymaster has agreed to cover the costs.

5. **Smart Contract Wallet Executes the Transaction:**
   If the validation step in `EntryPoint.sol` (which involves calling the SCW's validation logic) is successful, `EntryPoint.sol` then calls another function on the user's SCW to execute the actual intended operation. This is where the `callData` from the `UserOp` is executed (e.g., making a swap on Uniswap, or lending assets on Aave).

   - Importantly, during this execution phase, the `msg.sender` for the target dApp interaction will be the address of the user's SCW, not the Bundler or the `EntryPoint` contract. This ensures that from the perspective of other smart contracts, the SCW is the true originator of the action.
      The results of these operations are then recorded on the Ethereum blockchain.

6. **Optional EIP-4337 Add-ons:**
    - **Signature Aggregators:** `EIP-4337` supports the use of `Signature Aggregator` contracts. These contracts can be used by `EntryPoint.sol` to validate aggregated signatures (e.g., BLS signatures). This is particularly useful for multi-sig SCWs or for batching operations, as it can significantly reduce gas costs by verifying multiple signatures in a single operation.
    - **Paymasters:** As mentioned, a Paymaster is a smart contract that can agree to pay the gas fees for a `UserOp`. The `UserOp` can specify a Paymaster contract and include data that the Paymaster requires for its validation (e.g., a signature from the dApp sponsoring the transaction). If a Paymaster is used and successfully validates, it reimburses the Bundler via the `EntryPoint.sol` contract. If no Paymaster is used, the user's SCW must have sufficient native token balance, which `EntryPoint.sol` will transfer to the Bundler as compensation.

The `EIP-4337` flow, while powerful, involves several interconnected components: 
- The user's Smart Contract Wallet (SCW) 
- The `UserOp` object
- The `Alt Mempool`
- Bundlers
- `EntryPoint.sol` contract

### Native Account Abstraction: The zkSync Example

Blockchains with native Account Abstraction, such as `zkSync Era`, integrate **Account Abstraction** principles directly into their core protocol, often resulting in a simpler architecture for developers and users.

In zkSync Era:
- The roles of the `Alt Mempool` and Bundlers are effectively handled by the regular chain nodes/sequencers.
- **Every account is fundamentally a smart contract**. Even when a user creates an account using a familiar tool like MetaMask (which traditionally generates an EOA), zkSync automatically deploys a default smart contract account implementation for that address.
- This default account contract (e.g., `DefaultAccount.sol` in the `matter-labs/era-contracts` repository) implements standard interfaces like `IAccount` and includes functions such as `validateTransaction`, `executeTransaction`, and `isValidSignature`. By default, this contract mimics traditional EOA behavior, validating transactions based on an ECDSA signature from the associated private key.
- However, users or developers can **override** this default implementation by deploying custom smart contract code to their account address. This custom code can then define any arbitrary validation logic, effectively turning any account into a fully programmable smart contract wallet.

The simplified flow on a native **Account Abstraction** chain like `zkSync` might look like this:
1. **Off-Chain:** A signer (which could be a traditional private key, a social login mechanism, or a multi-sig scheme) signs the transaction data according to the account's logic.
2. **On-Chain:** The signed transaction is sent to `zkSync` nodes. These nodes natively understand **Account Abstraction** and can directly call the validation logic within the user's account contract.
3. If valid, the transaction is executed by the user's account contract, and the results are included in a block on the `zkSync` blockchain.

This native approach bypasses the need for a separate `Alt Mempool` and the `EntryPoint.sol` contract, as the core protocol itself is designed to handle programmable account validity.

## The Future is Abstracted: Enhanced Usability for Web3

**Account Abstraction**, whether through `EIP-4337` on Ethereum or via native implementations on Layer 2s and other blockchains, represents a monumental step towards improving blockchain usability.

While the `EIP-4337` mechanism on Ethereum involves a complex interplay of off-chain and on-chain components, its goal is to make interacting with Web3 applications as seamless and intuitive as using Web2 applications.

By abstracting away the complexities of private key management and gas payments, **Account Abstraction** paves the way for features like social recovery, sponsored transactions, spending limits, and much more. 

Ultimately, this will lower the barrier to entry, making decentralized technologies more accessible to a broader audience and helping to onboard the next wave of users into the crypto ecosystem.
